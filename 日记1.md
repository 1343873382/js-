## 箭头函数里单行没有大括号表示return

```
let res1= (r1,r2) => r1+r2;//3
    let res2= (r1,r2) => {r1+r2};//underfined
    let res3= (r1,r2) => {return (r1+r2)};3

```

## 出现在后面的函数声明会覆盖掉前面的

## 闭包中的变量都保存在内存中

```

function a(){
	var d=5;d=d+1;
	var b=1;
	function c(){
		console.log(b);
		console.log(d);
		return b++;
	}
	return c;
};
var e=a();
e();
e();
e();
//1,6,2,6,3,6
```

闭包不会重新执行，只会根据返回值调用c函数，从第一个e()开始，进入c()。右侧的变量值仍然变化

```
function a(){
	var d=5;
	var b=1;
	function c(){
		console.log(b);
		console.log(d);
		d++;
		return b++;
	}
	return c;
};
var e=a();
e();
e();
e();
1,5,2,6,3,7
```

## 箭头函数this的作用

```
var obj = {
count: 0,
cool: function coolFn() {
var that = this;
if (self.count < 1) {
setTimeout( function timer(){
that.count++;
console.log( "awesome?" );
}, 100 );
}
}
};
obj.cool(); // 酷吧？
var that = this 这种解决方案圆满解决了理解和正确使用 this 绑定的问题
```

```
var obj = {
count: 0,
cool: function coolFn() {
if (this.count < 1) {
setTimeout( () => { // 箭头函数是什么鬼东西？
this.count++;
console.log( "awesome?" );
}, 100 );
}
}
};
obj.cool(); // 很酷吧 ?
简单来说，箭头函数在涉及 this 绑定时的行为和普通函数的行为完全不一致
```

```
var obj = {
count: 0,
cool: function coolFn() {
if (this.count < 1) {
setTimeout( function timer(){
this.count++; // this 是安全的
// 因为 bind(..)
console.log( "more awesome" );
}.bind( this ), 100 ); // look, bind()!
}
}
};
obj.cool(); // 更酷了。
无论你是喜欢箭头函数中 this 词法的新行为模式，还是喜欢更靠得住的 bind() ，都需要
注意箭头函数不仅仅意味着可以少写代码
```

